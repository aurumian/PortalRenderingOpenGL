#version 440 core

#define MAX_NUM_DIR_LIGHTS 4

struct Material{
	sampler2D texture_diffuse0;
	sampler2D texture_specular0;
	float shiness;
};

uniform sampler2D shadowMap;
uniform usampler2D smStencil;

struct DirLight {			// base alignment | ofsset | aligned offset
	vec3 direction;			// 16	|	0	|	0
	float ambientStrength;	// 4	|	12	|	12
	vec3 color;				// 16	|	16	|	16
	float intensity;		// 4	|	28	|	28
	uint smStencilRef;		// 4	|	32	|	32
	mat4 lightSpaceMatrix;	// [0]16|	36	|	48
							// [1]16|	64	|	64
							// [2]16|	80	|	80
							// [3]16|	96	|	96
}; // total size - 112 bytes

layout (std140) uniform  DirLights {
	DirLight dirLights[MAX_NUM_DIR_LIGHTS]; // 112	| 0		| 0
	uint numDirLights;						// 4	| 448	| 448
};

struct PointLight{
	vec3 position;
	
	float ambientStrength;
	vec3 color;
	float intensity;

	float constant;
	float linear;
	float quadratic;
};

struct SpotLight{
	vec3 position;

	float ambientStrength;
	vec3 color;
	float intensity;

	vec3 direction;
	float cutoff;
	float outerCutoff;
};

in VS_OUT {
    vec3 FragPos;
    vec3 Normal;
    vec2 texCoord;
	vec4 fragPosLightSpace[MAX_NUM_DIR_LIGHTS];
    vec4 FragPosLightSpace;
    vec4 FragPosLightSpace2;
} fs_in;

uniform Material material;
uniform DirLight dirLight;
uniform DirLight dirLight2;
uniform PointLight pointLight = { {0.0f, 2.0f, 0.0f}, 0.1f, {1.0f, 1.0f, 1.0f}, 1.0f, 1.0f, 0.09f, 0.032f};
uniform SpotLight spotLight = {{0.0f, 0.0f, 0.0f}, 0.1f, {1.0f, 1.0f, 1.0f}, 1.0f, {0.0f, 0.0f, 1.0f}, 0.15, 0.23f };
uniform uint smRef;
uniform uint smRef2;

out vec4 FragColor;

vec3 GetBaseColor(){
	return texture(material.texture_diffuse0, fs_in.texCoord).xyz;
}

vec3 GetSpecularColor(){
	return texture(material.texture_specular0, fs_in.texCoord).xyz;
}

// TODO: write more flexible functions for calculating shadows and light
// for portals: only the outside light should give ambience, etc

float CalculateDirShadow(DirLight light, vec4 fragPosLightSpace, vec3 normal, vec3 lightDir, bool useRef) {
	
	vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
	projCoords = projCoords * 0.5f + 0.5f;
	float closestDepth = texture(shadowMap, projCoords.xy).r;
	float bias = max(0.005 * (1.0 - dot(normal, lightDir)), 0.0005);
	float currentDepth = projCoords.z;
	float shadow = currentDepth > closestDepth + bias  ? 1.0 : 0.0; 
	shadow = (projCoords.z > 1.0f) ? 0.0f : shadow;
	if (projCoords.z > 1.0f)
		shadow = 0.0f;

	// temp
	// first we need to know whether the light is in the same space as the camera (outside or inside the portal) 
	
	// for lights outside the portal
	uint stencil = texture(smStencil, projCoords.xy).r;
	if(useRef)
		shadow = stencil == light.smStencilRef ? shadow : 1.0;
	else if (stencil == smRef)
		shadow = stencil == smRef2 ? shadow : 1.0;


	// for lights inside the portal
	

	return shadow;
}

vec3 CalculateDirLight(DirLight light, vec3 normal, vec3 viewDir, vec4 lightSpacePos, bool useRef){
	vec3 baseColor = GetBaseColor();
	vec3 lightDir = normalize(-light.direction);
	// ambient shading
	vec3 ambient = baseColor * light.ambientStrength;
	// diffuse shading
	vec3 diffuse = max(dot(normal, lightDir), 0.0f) * baseColor;
	// specular shading
	vec3 reflectDir = reflect(-lightDir, normal);
	vec3 specular = pow(max(dot(viewDir, reflectDir), 0.0f), material.shiness) * GetSpecularColor();
	// shadows
	float shadow = CalculateDirShadow(light, lightSpacePos, normal, lightDir, useRef);
	
	vec3 lightCol = light.color * light.intensity;
	return (ambient + (1.0 - shadow) *(diffuse + specular)) * lightCol;
}

vec3 CalculatePointLight(PointLight light, vec3 normal, vec3 viewDir){
	vec3 baseColor = GetBaseColor();

	// attenuation
	float distance = length(light.position - fs_in.FragPos);
	float attenuation = 1.0f / (light.constant + light.linear * distance + light.quadratic * distance * distance);
	// ambient shading
	vec3 ambient = baseColor * light.ambientStrength;
	// diffuse shading
	vec3 lightDir = normalize(light.position - fs_in.FragPos);
	vec3 diffuse = max(dot(normal, lightDir), 0.0f) * baseColor;
	// spucular shading
	vec3 reflectDir = reflect(-lightDir, normal);
	vec3 specular = pow(max(dot(viewDir, reflectDir), 0.0f), material.shiness) * GetSpecularColor();
	
	vec3 lightCol = light.color * light.intensity;
	return (ambient + diffuse + specular) * lightCol * attenuation;
}

vec3 CalculateSpotLight(SpotLight light, vec3 normal, vec3 viewDir){
	vec3 baseColor = GetBaseColor();

	vec3 lightDir = normalize(fs_in.FragPos -light.position);
	vec3 spotDir = normalize(light.direction);
	float theta = dot(spotDir, lightDir);

	float phi = cos(light.cutoff);
	float gamma = cos(light.outerCutoff);
	
	vec3 ambient = vec3(0.0f, 0.0f, 0.0f);
	vec3 diffuse = vec3(0.0f, 0.0f, 0.0f);
	vec3 specular = vec3(0.0f, 0.0f, 0.0f);

	float alpha = clamp((theta - gamma)/(phi - gamma), 0.0f, 1.0f);


	ambient = baseColor * light.ambientStrength;
	diffuse = max(dot(normal, -lightDir), 0.0f) * baseColor;
	vec3 reflectDir = reflect(lightDir, normal);
	specular = pow(max(dot(viewDir, reflectDir), 0.0f), material.shiness) * GetSpecularColor();
	

	vec3 lightColor = light.color * light.intensity;
	return (ambient + diffuse + specular) * lightColor * alpha ;
}


void main() {
	vec3 normal = normalize(fs_in.Normal);

	vec3 viewDir = normalize(-fs_in.FragPos);

	vec3 res = //CalculateSpotLight(spotLight, normal, viewDir)
			 //+ CalculatePointLight(pointLight, normal, viewDir)
			 vec3(0.0, 0.0, 0.0);

	for (int i = 0; i < numDirLights; ++i)
	{
		res += CalculateDirLight(dirLights[i], normal, viewDir, fs_in.fragPosLightSpace[i], true);
	}	
	
    FragColor = vec4(res, 1.0f);
}
